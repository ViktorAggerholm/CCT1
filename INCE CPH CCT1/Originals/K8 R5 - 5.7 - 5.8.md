#CE #CCT1 
- - -
## Table of Contents

- [[#State Reduction|State Reduction]]
- [[#State Assignment|State Assignment]]
- [[#5.8 Design Procedure|5.8 Design Procedure]]
- [[#5.8 Design Procedure#Synthesis Using D Flip-flops|Synthesis Using D Flip-flops]]
- [[#5.8 Design Procedure#Excitation Tables|Excitation Tables]]
- [[#5.8 Design Procedure#Synthesis Using JK Flip-flops|Synthesis Using JK Flip-flops]]
- [[#5.8 Design Procedure#Synthesis Using T Flip-flops|Synthesis Using T Flip-flops]]

# 5.7 State Reduction and Assignment
## State Reduction
The reduction in the number of flip-flops in a seq. circuit is referred to as the *state-reduction* problem.
An unpredictable effect in reducing the number of flip-flops is that the circuit may require more combinational gates, to realize the next state and output logic.
![[Pasted image 20251028085531.png]]
![[Pasted image 20251028085803.png]]
In each column, we have the present state, input value, and output value. The next state is written on top of the next column

With two seq. circuits, where one has fewer states than the other, if identical input sequences are applied and identical outputs occur for all of those sequences, then the two circuits are said to be equivalent, and one may replace the other.

The problem of state reduction is to find ways of reducing the number of states in a sequential circuit without altering the input–output relationships.

To reduce the number of states.
- First we need the state table; since it's far more convenient to apply procedures for state reduction to a table, rather than a diagram.
```
The following algorithm for the state reduction of a completely specified state table is given here without proof: 

“Two states are said to be equivalent if, for each member of the set of inputs, they give exactly the same output and send the circuit either to the same state or to an equivalent state.” 

When two states are equivalent, one of them can be removed without altering the input–output relationships.`
```

- Going through the state table, we're searching for present states, that goes to the same next state and have the same output for both input combinations.
![[Pasted image 20251028112646.png]]
![[Pasted image 20251028112655.png]]
The present states *e* and *g* satisfy these conditions, both going to *a* and *f*, and have the outputs *0* and *1* for x =0 and x = 1.
![[Pasted image 20251028113613.png]]
Therefore the states *e* and *g* are equivalent, and one of these states is redundant.

To remove a state.
If the bottom row *g* is removed, the state *g* is replaced with *e*, each time *g* occurs in the "next state".
in *f* the next state for x = 0, would be changed from *g* to 'e', with the same outputs.
But now *f* and *d* would be equivalent, both going to *e* and *f*, with outputs *0* and *1*.
Thus *f* can also be removed.
Replacing the instances of *f* with *d* in the next state.
![[Pasted image 20251028114807.png]]
![[Pasted image 20251028135910.png]]

Checking each pair of states for equivalency can be done systematically by means of a procedure that employs an implication table, which consists of squares, one for every suspected pair of possible equivalent states. By judicious use of the table, it is possible to determine all pairs of equivalent states in a state table.

The fact that a state table has been reduced to fewer states does not guarantee a saving in the number of flip-flops or the number of gates. In actual practice designers may skip this step because target devices are rich in resources.
## State Assignment
In order to design a sequential circuit with physical components, it is necessary to assign unique coded binary values to the states.

For a circuit with m states, the codes must contain n bits, where 2^n >= m.

Unused states are treated as don’t-care conditions during the design, which usually help in obtaining simpler circuits.

![[Pasted image 20251028141618.png]]
![[Pasted image 20251028141653.png]]

The binary form of the state table is used to derive the nextstate and output-forming combinational logic part of the sequential circuit. The complexity of the combinational circuit depends on the binary state assignment chosen. Sometimes, the name transition table is used for a state table with a binary assignment. This convention distinguishes it from a state table with symbolic names for the states. In this book, we use the same name for both types of state tables.

# 5.8 Design Procedure
Design procedures or methodologies specify hardware that will implement a desired behavior.
For small circuits it may be done manually, but industry relies on automated synthesis tools for designing massive integrated circuits.

The sequential building block used by synthesis tools is the D flip-flop. 
Together with additional logic, it can implement the behavior of JK and T flip-flops.

Designers generally do not concern themselves with the type of flip-flop; rather, their focus is on correctly describing the sequential functionality that is to be implemented by the synthesis tool.

The design of a clocked sequential circuit starts from a set of specifications and culminates in a logic diagram or a list of Boolean functions from which the logic diagram can be obtained.
In contrast to a combinational circuit, which is fully specified by a truth table, a sequential circuit requires a state table for its specification.

The first step in the design of sequential circuits is to obtain a state table or an equivalent representation, such as a state diagram.

In a *synchronous* seq. circuit, design of the circuit consists of choosing the flip-flops and then finding a combinational gate structure.  That together fulfills the stated specs.
	The number of flip-flops is determined from the number of states needed in the circuit and the choice of state assignment codes.
The combinational circuit is derived from the state table by evaluating the flip-flop input equations and output equations.

The procedure for designing synchronous sequential circuits can be summarized by a list of recommended steps:
1. From the word description and specifications of the desired operation, derive a state diagram for the circuit.
2. Reduce the number of states if necessary.
3. Assign binary values to the states.
4. Obtain the binary-coded state table.
5. Choose the type of flip-flops to be used.
6. Derive the simplified flip-flop input equations and output equations.
7. Draw the logic diagram.
The first step is a critical part of the process, because succeeding steps depend on it. We will give one simple example to demonstrate how a state diagram is obtained from a word specification.
## Synthesis Using D Flip-flops
Once the state diagram has been derived, the rest of the design follows a straightforward synthesis procedure.

To design the circuit by hand, we need to assign binary codes to the states and list the state table.
![[Pasted image 20251028143043.png]]
![[Pasted image 20251028143103.png]]

![[Pasted image 20251028143209.png]]
![[Pasted image 20251028143130.png]]
The flip-flop input equations can be obtained directly from the next-state columns of *A* and *B* expressed in sum-of-minterms.
Where *A* and *B* are present-state values of the flip-flops, *x* is the input, *DA* and *DB* are the input equations.

The minterms for output y are obtained from the output column in the state table.
The Boolean equations are simplified by means of the maps:
![[Pasted image 20251028143426.png]]
The advantage of designing with D flip-flops is that the Boolean equations describing the inputs to the flip-flops can be obtained directly from the state table.
Software tools automatically infer and select the D -type flip-flop from a properly written HDL model.
## Excitation Tables
The design of a sequential circuit with flip-flops other than the D type is complicated by the fact that the input equations for the circuit must be derived indirectly from the state table.

In order to determine the input equations for these flip-flops, it is necessary to derive a functional relationship between the state table and the input equations

Each table has a column for the present state Q ( t ), a column for the next state Q(t + 1), and a column for each input to show how the required transition is achieved. 
There are four possible transitions from the present state to the next state. 

The required input conditions for each of the four transitions are derived from the information available in the characteristic table. 
The symbol X in the tables represents a don’t-care condition, 
which means that it does not matter whether the input is 1 or 0.
![[Pasted image 20251028143650.png]]

For the JK flip-flop, when both present state and next state are 0, the J input must remain at 0 and the K input can be either 0 or 1. Similarly, when both present state and next state are 1, the K input must remain at 0, while the J input can be 0 or 1.

If the flip-flop is to have a transition from the 0-state to the 1-state, J must be equal to 1, since the J input sets the flip-flop. However, input K may be either 0 or 1. If K = 0, the J = 1 condition sets the flip-flop as required; if K = 1 and J = 1, the flip-flop is complemented and goes from the 0-state to the 1-state as required. Therefore, the K input is marked with a don’t-care condition for the 0-to-1 transition

For a transition from the 1-state to the 0-state, we must have K = 1, since the K input clears the flip-flop. However, the J input may be either 0 or 1, since J = 0 has no effect and J = 1 together with K = 1 complements the flip-flop with a resultant transition from the 1-state to the 0-state.

For the excitation table for the T flip-flop, from the characteristic table, we find that when input T = 1, the state of the flip-flop is complemented, and when T = 0, the state of the flip-flop remains unchanged. Therefore, when the state of the flip-flop must remain the same, the requirement is that T = 0. When the state of the flip-flop has to be complemented, T must equal 1.
## Synthesis Using JK Flip-flops
The manual synthesis procedure for sequential circuits with JK flip-flops is the same as with D flip-flops, except that the input equations must be evaluated from the present-state to the next-state transition derived from the excitation table.
The flip-flop inputs are derived from the state table in conjunction with the excitation table for the JK flip-flop.
![[Pasted image 20251028144422.png]]
To do this conjunction we look at the next-state of the state table, and see that for the current state A=0 and next-state A=0. 
Then we look in the excitation table for the flip-flop A for the same condition where the present state Q and the next state Q+1 are also both 0, we find that a transition of states from present state 0 to next state 0 requires that input J be 0 and input K be a don’t-care. 
So 0 and X are entered in the first row under JA and KA, respectively. 

Since the first row also shows a transition for flip-flop B from 0 in the present state to 0 in the next state, 0 and X are inserted into the first row under JB and KB, respectively as well.

The second row of the table shows a transition for flip-flop B from 0 in the present state to 1 in the next state. 
From the excitation table, we find that a transition from 0 to 1 requires that J be 1 and K be a don’t-care, so 1 and X are copied into the second row under JB and KB, respectively. 

The process is continued for each row in the table and for each flip-flop, with the input conditions from the excitation table copied into the proper row of the particular flip-flop being considered.
![[Pasted image 20251028145057.png]]
![[Pasted image 20251028145108.png]]
## Synthesis Using T Flip-flops
![[Pasted image 20251028145151.png]]
An n -bit binary counter consists of n flip-flops that can count in binary from 0 to 2^n - 1.
	Remember that state transitions in clocked sequential circuits are initiated by a clock edge; the flip-flops remain in their present states if no clock is applied. For that reason, the clock does not appear explicitly as an input variable in a state diagram or state table.
Binary counters are constructed most efficiently with T flip-flops because of their complement property. 

The flip-flop excitation for the T inputs is derived from the excitation table of the T flip-flop and by inspection of the state transition of the present state to the next state.
The next state of a counter depends entirely on its present state, and the state transition occurs every time the clock goes through a transition.
![[Pasted image 20251028150502.png]]
As an illustration, consider the flip-flop input entries for row 001. The present state here is 001 and the next state is 010, which is the next count in the sequence. Comparing these two counts, we note that A2 goes from 0 to 0, so TA2 is marked with 0 because flip-flop A2 must not change when a clock occurs. Also, A1 goes from 0 to 1, so TA1 is marked with a 1 because this flip-flop must be complemented in the next clock edge. Similarly, A0 goes from 1 to 0, indicating that it must be complemented, so TA0 is marked with a 1. The last row, with present state 111, is compared with the first count 000, which is its next state. Going from all 1’s to all 0’s requires that all three flip-flops be complemented.

The flip-flop input equations are simplified in the maps:
	Note that TA0 has 1’s in all eight minterms because the least significant bit of the counter is complemented with each count. A Boolean function that includes all minterms defines a constant value of 1. The input equations listed under each map specify the combinational part of the counter.
![[Pasted image 20251028150450.png]]

![[Pasted image 20251028150513.png]]
	For simplicity, the reset signal is not shown, but be aware that every design should include a reset signal.