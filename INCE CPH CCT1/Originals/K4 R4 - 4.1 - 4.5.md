#CE #CCT1 
- - -
## Table of Contents

- [[#4.2 Combinational Circuits|4.2 Combinational Circuits]]
- [[#4.3 Analysis Procedure|4.3 Analysis Procedure]]
- [[#4.4 Design Procedure|4.4 Design Procedure]]
	- [[#4.4 Design Procedure#Code Conversion Example|Code Conversion Example]]
- [[#4.5 Binary Adder-Subtractor|4.5 Binary Adder-Subtractor]]
	- [[#4.5 Binary Adder-Subtractor#Half Adder|Half Adder]]
	- [[#4.5 Binary Adder-Subtractor#Full Adder|Full Adder]]
	- [[#4.5 Binary Adder-Subtractor#Binary Adder|Binary Adder]]
	- [[#4.5 Binary Adder-Subtractor#Carry Propagation|Carry Propagation]]
	- [[#4.5 Binary Adder-Subtractor#Binary Subtractor|Binary Subtractor]]
	- [[#4.5 Binary Adder-Subtractor#Overflow|Overflow]]

# Introduction
Logic circuits for digital systems can be:
- Combinational
Consists of logic gates whose output at any time are determined from only the present combination of inputs.
Can be specified logically by a set of Boolean functions.
- Sequential
Employ storage elements in addition to logic.
Outputs are functions of the inputs and the state of storage elements.
Depends not only on present and current values, but also past inputs, and must be specified by a time sequence of inputs and states.
# 4.2 Combinational Circuits
The *n* input variables, produce *m* output variables; by the internal combinational logic circuit, and go on to an external destination.
Each I/O variable exists physically as an analog signal, representing `logic 1` and `logic 0`.
	Some simulators show only the 1's and 0's, not the actual analogs.
![[Pasted image 20250929172452.png]]
Often the source of the outputs are *storage registers*.
	If the registers are included with the gates, the total circuit must be considered a sequential circuit
A combinational circuit can be specified by a truth table, that lists all output values for all input variables.
# 4.3 Analysis Procedure
The analysis of combinational circuits, requires that we determine the function they implement.
	This starts with a logic diagram, and culminates with a set of Boolean functions, a truth table and/or an explanation of the circuit operation.
If the diagram is accompanied by a function or an explanation; the analysis is reduced to a verification of the stated info.

The first step is to make sure the circuit is combinational and not sequential.
	*The diagram of a combinational circuit, has gates with no feedback paths or memory elements*.
After verifying the circuit, the next step is to find the Boolean functions or the truth table applicable to the circuit.
	If the function(s) of the circuit are under investigation, it's necessary to interpret the operation(s) of the circuit, in relation to the derived function(s) and truth table.

To obtain the output Boolean function(s) from a logic diagram, we must do:
1. Label all gate outputs that're a functions of input variables, with arbitrary symbols but meaningful names; to determine the Boolean functions for each gate output.
2. Label the gates that're a function of input variables, and previously labeled gates with other arbitrary symbols; to find the functions for these gates
3. Repeat '2' till the outputs of the circuit are obtained
4. By repeated substitution of previously defined functions, obtain the output Boolean functions in terms of input variables.

![[Pasted image 20250930074710.png]]
![[Pasted image 20250930074723.png]]

The Boolean functions *F1* and *F2* implement a circuit.
Merely finding a Boolean representation doesn't provide much insight into the behavior of the circuit. We can however observe that the Boolean equations and the truth table for *F1* and *F2*, match those describing the functionality of a *full adder*.

To obtain the truth table **without** going through derivations of the Boolean functions, we do:
1. Determine the number of input variables in the circuit.
	1. For *n* inputs, for 2^*n* possible input combinations, and list all the binary numbers
2. Label outputs of selected gates, with arbitrary symbols.
3. Obtain the truth table for the outputs of the gates, which're a function of **only** the input variables
4. Proceed to obtain the truth table for the output of the gates, which're a function of the previous *input-only* gates' defined values, and repreat untill the columns for all outputs are determined.
![[Pasted image 20250930115706.png]]
# 4.4 Design Procedure
The procedure for designing combinational circuits involves the following steps:
1. From the specs of the circuit, determine the required number of inputs and output of the circuit in its entirety, and assign a symbol to each.
2. Derive the truth table that defines the required relation between I/O.
3. Obtain the simplified Boolean functions for each output, as a function of the input variables
4. Draw the logic diagram, and verify the design (either manually or by simulation)

A truth table for a combinational, consists of input columns and output columns.
	The input columns are obtained from the binary numbers for the *n* input variables.
	The binary values for the outputs are determined from the specs
	The output functions in the table give the exact definition of the circuit. 
		The output functions listed in the table are simplified as much as possible and by any available method.

## Code Conversion Example
Due to large code-variety, it's sometimes necessary to use the output of one system, as the input of another.
	A *conversion circuit* must be inserted between the two, to translate from one code to another.

To convert from binary A to B, the input-lines must supply the bit combination from binary code A, and the output-lines must generate the corresponding version of elements for binary code B.

Since each code (in this example), uses 4-bit to represent a decimal digit, there must be four input and output variables.
*A*, *B*, *C*, *D* and *w*, *x*, *y*, *z*.
![[Pasted image 20250930135940.png]]
	*Note that a 4-bit truth table can have 16 possible bit combinations, but only 10 are shown*.
	The 6 not shown are "don't care" combinations, which have no meaning in our- input-code; BCD.
		Therefore we can give these 6 combinations any value, that leads a simpler circuit.


Using a K-map for each output variable, we obtain the simplified Boolean functions.
	One for each output of the circuit, as a function of all 4 inputs.
	With the "don't care" values mark *x*.
![[Pasted image 20250930142049.png]]
![[Pasted image 20250930142101.png]]
![[Pasted image 20250930142220.png]]

With the simplified Boolean functions, we can create a logic diagram implementing these expressions.
![[Pasted image 20250930142544.png]]
# 4.5 Binary Adder-Subtractor
Digital computers perform various arithmetic operations.
The most basic being addition of 2 binary digits; consisting of 4 possible elementary operations: `0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1, 1 + 1 = 10`.
A combinational circuit that performs the addition of two bits is called a *half adder*. One performing addition of 3 bits (2 bits and a carry) is called a *full adder*.

An *adder-subtractor*, is a combinational circuit that performs arithmetic of both addition and subtraction, with binary numbers.

## Half Adder
The circuit needs 2 inputs and outputs.
The inputs are designate the augend and the addend bits; the output variables produce the sum and the carry.
We assign the inputs *x* and *y*, and *S* to the sum, *C* to the carry.
The C variable represents the most significant bit the *carry bit*.
The S variable represents the least significant bit in the sum.
![[Pasted image 20250930143723.png]]
![[Pasted image 20251002074912.png]]
	*As shown the Carry variable is only one when all inputs are one. While the Sum variable, shows the least significant bit.*
![[Pasted image 20251002074943.png]]
## Full Adder
Addition of *n*-bit binary numbers, requires a *full adder*.
The process of addition proceeds bit-by-bit, starting right to left, with the right-most, least significant bit.
	Each position through the process add not only the respective bits; but also consider a possible carry from addition performed at the previous position.
A **full** adder is a combinational circuit performing arithmetic on three bits, consisting of 3 inputs and two outputs.
Two of the inputs *x* and *y* represent two significant bits to be added, the third *z* represents the possible carry obtained from the previous lesser significance position.
The outputs are the sum *S* and the carry *C*.
	*S* giving the least significant bit of the sum, *C* giving the output carry formed by adding the input carry and the bits.
![[Pasted image 20251002080351.png]]
![[Pasted image 20251002080359.png]]
	*As shown the Carry variable is only one when two or more inputs are one. While the Sum variable, shows the least significant bit.*
![[Pasted image 20251002080653.png]]
![[Pasted image 20251002080705.png]]
The *S* output from the 2nd half adder is equal to the XOR of *z* and the output of the first adder:
![[Pasted image 20251002080831.png]]
## Binary Adder
A *binary adder* is a digital circuit, producing the arithmetic sum of two binary numbers, constructed with full adders connected in cascade, with the output-carry from each connected to the input-carry of the next in the chain.
![[Pasted image 20251002081056.png]]
Addition of *n*-bit numbers, requires a chain of *n* full adders, or 1 half-adder and *n-1* full adders.
With all full adders (FA), the input carry to the least significant position is fixed at 0.

For a *n=4*-bit adder, the augend bits *A* and addend bits *B* are designated with subscript, right to left, with 0 being the least significant bits.
![[Pasted image 20251002081556.png]]
![[Pasted image 20251002081607.png]]
## Carry Propagation
The addition of numbers in parallel, implies that all bits of *A* and *B*. are available at the same time.
However, as in any circuit, the signal must propagate through the circuit and its parts before the correct output sum is available at the output terminal.
The longest propagation delay in an adder is the time it takes the carry to propagate through the full adders.

Since each bit sum *output* depends on the value of the *input* carry, the value of *S* at any given stage in the adder will be in the final value, only **after** the input to that stage has propagated.
	Input carry C3 doesn't settle until C2 is available from the output of the previous adder, so on for C2 to C1, and C1 to C0.
	Thus the outcome *C5* will only settle after the carry has propagated through the all stages.

For an *n*-bit adder, there're *2n*-gate levels for the carry to propagate from ultimate input to ultimate output; since the signal from the input carry to the output in a single adder propagates through an AND and an OR gate, per adder.
![[Pasted image 20251002173718.png]]

The carry propagation time is an important attribute of the adder, because it limits the speed two numbers can be / are added.
	The value at the ultimate output terminal is only correct once the signals have propagated from the ultimate inputs
there're several techniques for reducing the propagation time; most widely used is the principle of *carry lookahead logic*.
![[Pasted image 20251002174154.png]]
![[Pasted image 20251002174214.png]]
![[Pasted image 20251002174225.png]]
Since the Boolean function for each output-carry is expressed as a sum-of-products, each can be implemented with one level of AND gates followed by an OR gate.
![[Pasted image 20251002174849.png]]
Each sum output requires two XOR gates.
- The first XOR's output generates the *Pi* variable, and the AND gate generates the *Gi* variable
The carries are propagated through the lookahead and applied as inputs to the second.
All output carries are generated after a delay through 2 levels of gates, thus *S1* and *S3* have equal propagation times.
![[Pasted image 20251002174906.png]]
## Binary Subtractor
The subtraction of unsigned binary numbers can be done by means of complements.
The circuit for subtracting *A - B* consists of an adder with inverts placed between each data input *B* and the corresponding input of the full adder.
	The operation performed then becomes *A* + *r-1*'s complement of *B* + 1.
	This is equal to *A* + *r*'s complement of B.
	Equal to *A* - *B*, for unsigned numbers, if A >= B or *r*'s complement of *B - A* if A < B.
		For signed numbers the result is *A - B*, provided there's no overflow.

Addition and subtraction can be combined into one circuit with one common binary adder, by including a XOR gate with each full adder.
![[Pasted image 20251002181917.png]]
In a 4-bit adder-subtractor circuit, the input mode *M* controls the operation (addition or subtraction).
	When *M*=0 the circuit is adder
	*M*=1 the circuit is subtractor.
![[Pasted image 20251002182845.png]]
## Overflow
When two numbers of *n* digits each are added and the sum is  number of *n+1*; this is called and overflow.
	This is true for any number type
	- signed, unsigned
	- binary, hex, decimal....
When performed on paper an overlow isn't an issue, since there's not digit limit; in digtal computers however, because the number of bits that hold the numberis finite, a result *n+1* is bigger than the bits of an *n*-bit word and cannot be accommodated.

The detection of an overflow after addition depends on whether the numbers are considered signed or unsigned.
- When two *unsigned* numbers are added, an overflow is detected from the end carry, out of the most significant (left-most) position
- For signed numbers, the left-most bit always represents the sign, and negative numbers are *r*'s-complement. When two signed numbers are added, the *sign*-bit is treated as part of the number, and the end carry doesn't indicate an overflow.
An overflow cannot occur when one number is positive and the other negative.
![[Pasted image 20251003070656.png]]
	*Note that the 8-bit result that should have been positive has a negative sign bit, and the negative has a positive sign. If however the carry out of the sign bit position is taken as the sign bit of the result, then the 9-bit answer obtained will be correct. But the answer cannot be accommodated within 8 bits, an overflow has occurred*.
An overflow condition can be detected by observing the carry into the sign-bit position, and the carry out of the sign-bit position. If these carries are **not** equal, an overflow has occurred.
If two carries are applied to a XOR gate, an overflow is detected if the gate output is 1.
	For this method to work, *r*'s complement of a negative number, must be computed by taking *r-1*'s complement, then adding 1.
In a binary adder-subtractor with outputs *C* and *V*, if the two binary numbers are unsigned, then the *C*-bit detects a carry after addition or a borrow after subtraction.
If the numbers are considered signed, then the *V*-bit detects an overflow
	If *V*=0 after an addition or subtraction, no overflow occured, and the *N*-bit result is correct.
	If *V*=1, then the result of the operation contains *n+1*-bits, but only the right-most *n* bits of the number fit in the space available; an overflow occured.
		The (*n+1*)-th-bit is the sign bit, that has shifted out of position.
