---
tags:
  - CCT1
  - CE
Topic: Basic Theorems and Properties of Boolean Algebra
Semester: CCT1
Course: CE1
Module: K1
Course Date: N/A
Litterature:
  - Digital Design, 5th ed.
Created: 16-11-25
---
- - -
## Table of Contents

- [[#Duality|Duality]]
- [[#Basic Theorems|Basic Theorems]]
- [[#Operator Precedence|Operator Precedence]]
- [[#2.5 Boolean Functions|2.5 Boolean Functions]]
- [[#2.5 Boolean Functions#Algebraic Manipulation|Algebraic Manipulation]]
- [[#2.5 Boolean Functions#Complement of a Function|Complement of a Function]]
- [[#2.6 Canonical and Standard Forms|2.6 Canonical and Standard Forms]]
- [[#2.6 Canonical and Standard Forms#Minterms and Maxterms|Minterms and Maxterms]]
- [[#2.6 Canonical and Standard Forms#Sum of Minterms|Sum of Minterms]]
- [[#2.6 Canonical and Standard Forms#Product of Maxterms|Product of Maxterms]]
- [[#2.6 Canonical and Standard Forms#Conversion Between Canonical Forms|Conversion Between Canonical Forms]]
- [[#2.6 Canonical and Standard Forms#Standard Forms|Standard Forms]]
	- [[#Standard Forms#1) The sum of products|1) The sum of products]]
	- [[#Standard Forms#2 The products of sums|2 The products of sums]]
- [[#2.8 Digital Logic Gates|2.8 Digital Logic Gates]]
- [[#2.8 Digital Logic Gates#Extension to Multiple Inputs|Extension to Multiple Inputs]]
- [[#2.8 Digital Logic Gates#Positive and Negative Logic|Positive and Negative Logic]]

# 2.4 Basic Theorem and Properties of Boolean Algebra
## Duality
An important property of Boolean algebra is the *duality principle*, which states that every algebraic expression deducible, remains valid if the operators and identity elements are interchanged.
The *duality principle* means that, if the **dual** of an algebraic expression is desired, you interchange the OR and AND operators, and replace 1's by 0's and 0's by 1's.
## Basic Theorems
![[Pasted image 20250922174450.png]]
The theorems, like the postulates, are listed in pair; each relation is the dual of the one paired with it.
The *postulates* are basic axioms of the algebraic structure.
![[Pasted image 20250922174628.png]]
![[Pasted image 20250922174636.png]]
*Note that 1(b) is the dual of 1(a), each step of proof (b) is the dual of the counterpart in proof (a)*. This is the case for all proofs of all dual theorems.

![[Pasted image 20250922175238.png]]
![[Pasted image 20250922175246.png]]

![[Pasted image 20250922175257.png]]
![[Pasted image 20250922175445.png]]

![[Pasted image 20250922175507.png]]

The theorems of Boolean algebra can be proven by use of truth tables.
In these truth both relations are checked to see whether they yield the same results, for all possible combinations of the variables involved.
![[Pasted image 20250922175747.png]]
![[Pasted image 20250922175842.png]]
	Looking in the **Operator Precedence** list, we see the order of operation to check the truth table for Theorem 5, DeMorgan's Theorem.
	On the L side of the expression we see `(x + y)'` 
	The expression inside the parentheses is evaluated first (OR operator), then the result complemented (NOT operator).
	On the R side the expression is `x'y'` So the complements (NOT operator) of `x` and `y` are evaluated first, and the results then AND'd (AND operator, not shown as it's written implicitly like the times operator in regular arithmetic)
## Operator Precedence
The order of resolution of Boolean expressions, also called *Operator Precedence* is:
1. Parentheses
2. NOT Operator
	(Complement)
3. AND Operator
4. OR Operator


# 2.5 Boolean Functions
Boolean algebra, is an algebraic system that utilizes **binary** variables and logic operations.
A *Boolean Function* described by an algebraic expression, consists of *binary variables*, the *binary constants* 0 and 1, and the *Boolean logic operation* symmbols.
	For the given value of the binary variables; the function can be equal to either 1 or 0

Consider the following *Boolean function*:
![[Pasted image 20250922182833.png]]
![[Pasted image 20250922182941.png]]
```
F1 = 1 IF,
x = 1 since 1 in any position of the OR operation will = 1.
or IF,
y = 0 and z = 1, since the NOT operation of y will then be 1, and the AND operation will then be 1 AND 1, which becomes 1.
```

A Boolean function can also be represented in a truth table.
	The number of rows in the table is 2^*n*, where *n* is the number of variables in the function.
		The binary combinations for the table are obtained by counting through 0 to 2^*n* - 1.

![[Pasted image 20250922183714.png]]
![[Pasted image 20250922183440.png]]

In *logic-circuit diagrams* the variables of the function are taken as *inputs* of the circuit, and the binary variable *F1* is taken as the *output* of the circuit.

There's only one way a Boolean function can be represented in the truth table.
	When the function is in *algebraic form*, it can be expressed in a variety of ways; all of which have equal logic.

The expression used to represent the function, dictates the interconnection of gates in the logic-circuit diagram.
	Conversely the interconnection of gates, will dictate the logic expression.

By manipulating a Boolean expression, according to the rules of Boolean algebra, it's sometimes possible to obtain a simplified/simpler expression for the same function, reducing the number of gates and IOs; reducing the complexity of the circuit.
	Designers are motivated and encouraged to reduce the complexity of their circuits, the effort can considerably reduce the cost of a circuit.

![[Pasted image 20250922192043.png]]
![[Pasted image 20250922192112.png]]
![[Pasted image 20250922192321.png]]
## Algebraic Manipulation
When implemented, a each term of a Boolean expression requires a gate, and each variable designates and input to the gate(s).
A *literal* is defined as a single variable within a term, in complemented or uncomplemented form.

By reducing the number of terms and literals in a Boolean expression, it's often possible to obtain a simpler circuit.
	Functions of up to five variables can be siplified by the *map method*.
	For complex Boolean functions, and many diffrent outputs; designers of digital circuits use computer minimization programs and algorithms that calculate the optimal circuits, even with millions of logic gates.

![[Pasted image 20250922193326.png]]
## Complement of a Function
The complement of a function is obtained from an interchange of 0's and 1's in the value of the primary function *F*.
It may be derived algebraically through DeMorgan's theorems for two variables, which can be extended for 3+ variables.
![[Pasted image 20250922193628.png]]

DeMorgan's theorems for *n* variables, resembles the two-variable case; and can be derived by successive substitutions.
![[Pasted image 20250922193813.png]]
	The generalized form of DeMorgan's theorems states that the complemnt of F is obtained by interchanging AND and OR operators, and complementing each literal.

![[Pasted image 20250922193941.png]]
![[Pasted image 20250922194005.png]]
# 2.6 Canonical and Standard Forms
## Minterms and Maxterms
- A binary variable may appear as either normal or complement form
- If two variables (*x* and *y*) are combined with an AND operator. This combination has four possible variations `x'y', x'y, xy', xy`. 
Each of these four AND terms, is called a *minterm* or a *standard product*.
	*n* variables can be combined to form 2^*n* *minterms*.
![[Pasted image 20250922194614.png]]
Each *minterm* is obtained from an AND term of *n* variables, with each variable being primed (*x'*) if the corresponding bit is a 0, and unprimed (*x*) if a 1.
![[Pasted image 20250924130656.png]]

Similarly *n* variables forming an OR term, with each variable being primed (*x'*) or unprimed (*x*), provide 2^*n* possible *maxterms* or *standard sums*, except reversed compared to *minterms*.
	It's important to note, each *maxterm* is obtained from an OR term of *n* variables, with each variable being unprimed if the corresponding bit is 0  (*x*) and primed (*x'*) if it's 1; each *maxterm* is the complement of its corresponding *minterm*.
***A Boolean function can be expressed algebraically from a given truth table by forming a minterm for each combination of the variables that produces a 1 in the function and then taking the OR of all those terms.***
![[Pasted image 20250922204530.png]]

![[Pasted image 20250922204547.png]]
![[Pasted image 20250922204615.png]]

![[Pasted image 20250922204635.png]]

***Boolean functions expressed as a sum of minterms or product of maxterms are said to be in canonical form***
![[Pasted image 20250924130737.png]]
## Sum of Minterms
The *minterms* whose *sum* defines the Boolean function are those which give the 1’s of the function in a truth table.
	Since the function can be either 1 or 0 for each minterm, and since there are 2^*n* minterms, one can calculate all the functions that can be formed with n variables to be 2^*2n* .
	It's sometimes convenient to express a Boolean function in its sum-of-minterms-form.
		If the function is not in this form, it can be made so by first expanding the expression into a sum of AND terms.
		Each term is then inspected to see if it contains all the variables. If it misses one or more variables, it is AND'd with an expression such as *x* + *x*, where *x* is one of the missing variables
	![[Pasted image 20250922205141.png]]
	![[Pasted image 20250922205210.png]]
***An alternative procedure for deriving the minterms of a Boolean function is to obtain the truth table of the function directly from the algebraic expression and then read the minterms from the truth table.***

![[Pasted image 20250922205306.png]]
*Diregarding the F where A, B, C are all 0*
## Product of Maxterms
**Each of the 2^2n functions of n binary variables can be also expressed as a product of maxterms.**

To express a Boolean function as a *product of maxterms*, it MUST first be brought into a form of OR terms.
	This is done using the distributive law.
	`x + yz = (x + y)(x + z)`
	Then any missing variable *x* in each OR term is OR'd with *xx'*.
![[Pasted image 20250922205801.png]]
![[Pasted image 20250922205812.png]]
## Conversion Between Canonical Forms
The complement of a function expressed as a sum of minterms, equals the sum of minterms missing from the original function.
This is because the original function is expressed by the minterms that make the function = 1
![[Pasted image 20250922210148.png]]
![[Pasted image 20250922210412.png]]

- The *maxterm* with subscript *j* (Mj), is equal to the complement of the minterm with subscript *j*.

Demonstrating the conversion between a function expressed as a sum-of-minterms and its equivalent product-of-maxterms.
Of the Boolean expression:
![[Pasted image 20250922211637.png]]
1. We derive the truth table of the function. The 1's under *F* in the table are determined from the combination of the varaiables for which x y = 1 1 or x z = 0 1.
	The function expressed as a sum of minterms = 
	![[Pasted image 20250922211711.png]]
2. Since there's a total of **eight** min-/maxterms in a function of three variables. 
	We determine the missing terms from 
	the sum of minterms to =
	![[Pasted image 20250922211845.png]]
![[Pasted image 20250922211732.png]]
## Standard Forms
The *canonical forms* of Boolean algebra are basic forms, obtained from reading the truth table.
	These forms are seldom the ones with the least amount of literals; since each min-/maxterm mut contain **all** the variables, either complemented or uncomplemented.
Another wat to express Boolean functions is *standard form*.
	In this config. the terms forming the function may contain one, two or any number of literals.
	There're 2 types of standard forms
### 1) The sum of products
The *sum of products* is a Boolean expressing containing the AND terms, also called *product terms*, with 1 or more literals each.
The *sum* denotes the OR'ing of these terms
	![[Pasted image 20250922212701.png]]
		This expression has 3 *product terms* with one, two and three literals respectively.
		Their *sum* is, in effect, an OR operation
		*The logic diagram of a sum-of-products expression, consists of a group of AND gates follwed by a single OR gate*
		![[Pasted image 20250922213032.png]]
		The *logic sum* is formed with this OR gate, whose inputs are the outputs of the AND gates, and the single literal directly. 
			This circuit config. is referred to as a *two-level implementation*
### 2 The products of sums
The *product of sums* is a Boolean expression containing OR terms, also called *sum terms*, each term may have any number of literals.
The *product* denotes the AND'ing of there terms.
	![[Pasted image 20250922213626.png]]
		This expression has 3 *sum terms*, with one, two and three literals respectively.
		Their *product* is an AND operation.
		*The logic diagram of a product of sums expression consists of a group of OR gates followed by a single AND gate.*
		![[Pasted image 20250922213932.png]]
		The *logic product* is formed with this AND gate, whose inputs are the outputs of the OR gates, and the single literal directly. 

A Boolean function may be expressed in a non-standard form.
![[Pasted image 20250922214233.png]]
	This is neither a sum of products or a product of sums form.
	Implementation of this expression requires two AND and OR gates. 
	![[Pasted image 20250922214428.png]]
	There're three levels of gating in this circuit; however it can be changed to standard form, using the distributive law to remove parentheses.
	![[Pasted image 20250922214541.png]]
		![[Pasted image 20250922214614.png]]

In general, a two-level implementation is preferable, since it produces the least amount of delay through the gates, when the signal propegates from input(s) to output(s).
	The number of inputs to a given singular gate might not be practical, however.
# 2.8 Digital Logic Gates
Boolean functions are expressed using AND, OR and NOT operations, making it easier to implement these functions using the corresponding gates.
	The possibility of constructing gates for other logic operations, is still of practical interrest
There're 4 factors to consider in constructuion of other types of logic gate:
1. Feasibility and economy of production
2. Possibility of extending the gate to more than 2 inputs
3. Basic properties of the corresponding binary operator
4. Ability of the gate to implement Boolean functions alone, or in junction with other gates.

Of the 16 defined functions two = a constant, four are repeats, leaving ten functions.
![[Pasted image 20250923070326.png]]
Of these ten functions two  (inhibition and inplication) are not commutative or associative, thus impractical to use as standard logic gates; leaving eight candidates.
1. Complement (NOT)
2. Transfer
3. AND
4. OR
5. NAND (NOT + AND)
6. NOR (NOT + OR)
7. XOR (exclusive-OR)
8. Equivalence (exlusive-NOR)
![[Pasted image 20250923070130.png]]
	Each gates has 1-2 input variables *x* and *y*, and one binary output variable *F*.
	The *Inverter* circuit produces the NOT, or complement, function of the input.
	The *Buffer* circuit produces the *transfer* function, but doesn't produce a logic operation, since the binary value of the input remains unchanged
		This circuit is used for power amplification of a signal, and is equal to two *Inverter* circuits in series.
- The *AND* circuit produces the AND function of the inputs.
- The *OR* circuit produces the OR function of the inputs.
- The *NAND* circuit produces the NOT function of the AND operation of the input. Or the complement to the output of a standard AND gate.
- The *NOR* circuit produces the NOT function of the OR operation of the input. Or the complement to the output of a standard OR gate.
- The XOR circuit, Produces the NOT function of the output, if all input are 1, meaning it's looking for cases where exclusively 1 input is 1, while the rest is 0.
- The *Equivalence* circuit, Produces the NOT function to the output of the XOR circuit. Meaning it's looking for cases where all inputs are exclusively the same value (either 0's or 1's).
## Extension to Multiple Inputs
All standard gates, except the Inverter and Buffer, can be extended to have more than 2 inputs.
	A gate can be extended, only if the binary operation represented is commutative and associative.
![[Pasted image 20250923074138.png]]
![[Pasted image 20250923074217.png]]
![[Pasted image 20250923074500.png]]
The exclusive-OR and equivalence (exclusive-NOR) gates are both communative and associative, and thus can be extended.
![[Pasted image 20250923154030.png]]
## Positive and Negative Logic

The binary signal at the inputs and outputs of any gate has one of two values, except during transition. 
	One signal value represents logic 1 and the other logic 0.
Since two signal values are assigned to two logic values, there exist two different assignments of signal level to logic value. The higher signal level is designated by *H* and the lower signal level by *L*.
![[Pasted image 20250923154016.png]]
- Choosing the high‐level *H* to represent logic *1* defines a *positive logic system*. Choosing the low‐level *L* to represent logic *1* defines a *negative logic system*.
![[Pasted image 20250923153935.png]]
![[Pasted image 20250923154115.png]]

The conversion from positive logic to negative logic and vice versa is essentially an operation that changes 1’s to 0’s and 0’s to 1’s in both the inputs and the output of a gate. Since this operation produces the dual of a function, the change of all terminals from one polarity to the other results in taking the dual of the function.
	The upshot is that all AND operations are converted to OR operations (or graphic symbols) and vice versa. In addition, one must not forget to include the polarity‐indicator triangle in the graphic symbols when negative logic is assumed.