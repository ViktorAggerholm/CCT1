#CE #CCT1 
- - -
## Table of Contents

- [[#4.9 Decoders|4.9 Decoders]]
	- [[#4.9 Decoders#Combinational Logic Implementation|Combinational Logic Implementation]]
- [[#4.10 Encoders|4.10 Encoders]]
	- [[#4.10 Encoders#Priority Encoder|Priority Encoder]]
- [[#4.11 Multiplexers|4.11 Multiplexers]]
	- [[#4.11 Multiplexers#Boolean Function Implementation|Boolean Function Implementation]]
	- [[#4.11 Multiplexers#Three-state Gates|Three-state Gates]]

# 4.7 Binary Multiplier
Multiplication of binary numbers is done the same way as decimal.
The multiplicand is multiplied by each bit if the multiplier, starting from the least significant.
Each operation yields a partial product, successive partial products are shifted one position to the left, the final product is obtained from the sum of the partials.
![[Pasted image 20251007144634.png]]
The multiplicand bits *B1* and *B0*, the multiplier bits *A1* and *A0* and the product bits *C3 to C0*.
The first partial is formed by multiplying *B1B0* by *A0*.
	The multiplication of two bits produces a 1 if both are 1; 0 otherwise. Identical to an AND operation.
Second partial is formed by multiplying *B1B0* by *A1*, and shifting one position to the left.
The two partials are then added in a Half-Adder (HA), usually there're more than 2 bits, and it's neccesary to use full adders to produce the sum of the partials.
A bit of the multiplier is ANDed with each bit of the multiplicand in as many levels as there're bits in the miltiplier. The binary output in each level is added with the partial product of the previous level, to form a new partial product.
The last level then produces the real product.
![[Pasted image 20251008124030.png]]
![[Pasted image 20251008124038.png]]
![[Pasted image 20251008124047.png]]
![[Pasted image 20251008124056.png]]
![[Pasted image 20251008124106.png]]

For *J* multiplier- and *K*-multiplicand-bits we need *J x K* AND gates and *J-1* K-bit adders, to produce a product of *J + K*-bits.

![[Pasted image 20251007152753.png]]
# 4.9 Decoders
![[Pasted image 20251008130353.png]]
A *decoder* is a combinational circuit that converts binary information from *n* inputs, to a maximum of 2^*n* unique outputs.
	If the coded information has unused combinations, the decoder may also have fewer outputs.
There multiple types of decoders, most commonly *n*-to-*m*-line decoders, where *m <= 2^n*.
The name decoder is also used in conjunction with other code converters such as BCD-to-7-segment decoders, or translators like BCD-to-binary decoders.

![[Pasted image 20251007153347.png]]
![[Pasted image 20251008130419.png]]
![[Pasted image 20251008131114.png]]
The three inputs are "decoded" into eight outputs, each representing a minterm of the 3 input variables.
	The inverters generate the complements of the inputs, and each AND gate generates on the the minterms.
This particular decoder is used in binary-to-octal conversion.
With the binary input variable being decoded to the respective value in the octal system.
![[Pasted image 20251007153707.png]]

![[Pasted image 20251007163427.png]]

A decoder with an enable input can funtion as a *demultiplexer*, a curcuit that recieves information from a single line, and directs it to one of 2^n possible outputs.
The selection of a specefic output, is controlled by a bitcombination of *n* selection lines.

Decoders with enables can be connected together to form larger decoders.
![[Pasted image 20251007163858.png]]
## Combinational Logic Implementation
Since any Boolean function can be expressed as a sum-of-minterms, a decoder that generates minterms of the functions, together with an external OR gate that forms their logical sum; provides a hardware implementation of the function.
In this way, any combination with *n* inputs and *m* outputs can be implemented with an *n*-to-*2^n*-line decoder and *m* OR gates.

![[Pasted image 20251007164321.png]]
Since there're three inputs and 8 total minterms, we use a 3-to-8-line decoder.
![[Pasted image 20251007164411.png]]
The decoder generates the 8 minterms for *x*, *y*, *z*. The Or gates for output *S* form the logical sum of minterms 1, 2, 4 & 7, The *C* OR gate forms the sum of 3, 5, 6 & 7.

A function having a list of *k* minterms can be expressed in its completed form *F'* with *2^n - k* minterms.
If the number of minterms is greater than 2^*n* / 2, then *F'* can be expressed with fewer minterms.

# 4.10 Encoders
An *encoder* is a digital circuit that performs the inverse operation of the *decoder*; taking 2^*n* or fewer inputs and generating *n* outputs.
![[Pasted image 20251007165028.png]]
![[Pasted image 20251007165038.png]]
The encoder shown has the limitation that only 1 input may be active at a time, more than one and the encoder generates an undefined combination of outputs.
## Priority Encoder
A *priority Encoder* is a type of encoder that includes the *priority function*; such that if two or more inputs are 1, the input having the highest priority will take precedence. 
![[Pasted image 20251007165416.png]]
In addition to the outputs *x* and *y*, there's a third value *V*; this is the *valid* bit indicator set to 1 when 1 or more values is 1, and 0 otherwise.
	The x and y values are not inspected if V is 0
![[Pasted image 20251007165621.png]]
![[Pasted image 20251007165712.png]]
![[Pasted image 20251007165721.png]]
# 4.11 Multiplexers
A *multiplexer* selects binary information from one of multiple inputs, and directs it to a single output. The selection of a particular input is controlled by a set of selection lines.
Normally there're 2^*n* inputs and *n* selection lines whos bit combination determine the input selected.
![[Pasted image 20251007170024.png]]
A 2-1-line MUX connects one of two 1-bit sources to the output. The circuit has 2 input data-lines, an output line and a selection line *S*.
When *S*=0, the upper AND gate is enabled, and *I0* goes to the output, if *S*=1, *I1* goes to the output.
![[Pasted image 20251007170303.png]]
a 4-1-line MUX has 4 inputs *I0* to *I3* each applied to the input of an AND gate, the singular output *Y*, and 2 selection lines *S0* and *S1* going into the 2nd input of the AND gates.
The value(s) of the selection lines controls which input goes through the MUX.
![[Pasted image 20251008134810.png]]
## Boolean Function Implementation
An exmaination of the logic diagram of a MUX reveal that it's essentially a decoder that includes the Or gate within the circuit.
![[Pasted image 20251007170753.png]]
The minterms of the function are generated within the MUX, by the circuit associated with the selection inputs.
The individual minterms can be selected by the data inputs, thereby providing a method of implementing a Boolean function of *n* variables with a multiplexer that has n selection inputs and 2^*n* data inputs, one for each minterm.
There's a more efficient method for implementing a Boolean function of *n* variables, using a MUX with *n-1* selection inputs.
	The last single variabel is used for data inputs. Denoted by *z*
![[Pasted image 20251007171112.png]]
This variable has 3 inputs, that can be implemented with a 4-1-line MUX.
*x* and *y* are applied to the selection lines, in that order, *x* connected to *S1* and *y* to *S0*.
The values for the data input lines are determined by the truth table.
When *xy* = 00, the output *F* is = *z* since *F* = 0 when *z* = 0 and *F* = 1 when *z* = 1.
	This requires that *z* is applied to the data input.

The general procedure of implementing a Boolean function of *n* variables with a multiplexer *n-1* selection inputs and 2^*n-1* data inputs.
First the funtion is listed in a truth table, then the first *n-1* variables of the table are applied to the selection lines.
For each combination of the selection variables, we evaluate the output function of the last variable, this function can be 0 or 1; the variable or the complement of the variable.
These values are then applied to the data inputs in the proper order.
![[Pasted image 20251007171841.png]]
![[Pasted image 20251007171855.png]]
Data inputs are determined form the truth table.
The corresponding data line number is determined from the bynary combination of *ABC*.

## Three-state Gates
![[Pasted image 20251007172057.png]]![[Pasted image 20251007172100.png]]